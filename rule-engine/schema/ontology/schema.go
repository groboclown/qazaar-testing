// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package ontology

import "encoding/json"
import "fmt"
import "reflect"

// Document author comment text.
type Comment string

// List of document author comments.
type CommentList []Comment

// A shared primary document reference.  Source locations can refer to this
// document through the identifier, but should also include an anchor.
type CommonDocumentSource struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id Id `json:"id" yaml:"id" mapstructure:"id"`

	// The resource identifier within the 'repo'.  Depending on the repo type, this
	// most likely has a required format for that repository.
	Loc string `json:"loc" yaml:"loc" mapstructure:"loc"`

	// General repository category containing the source.  This might be 'git' if
	// stored in a Git repository, or 'aws-s3', if stored in an Amazon S3 key store,
	// or 'intranet' if stored in an Intranet source.  The different programs may have
	// their own requirements for this value.  It does not define a location within
	// the repository, though.
	Rep string `json:"rep" yaml:"rep" mapstructure:"rep"`

	// An identifier to reference the unique version of the source, as dictated by the
	// repository type.  This might a commit id, or document revision, or a date-time
	// stamp.  The repository type may not have the ability to retrieve this version
	// (someone may have deleted it, or the repository does not support versioning).
	Ver *string `json:"ver,omitempty" yaml:"ver,omitempty" mapstructure:"ver,omitempty"`
}

// Pool of document source references, which may be referenced from the source
// locations.
type CommonDocumentSourceList []CommonDocumentSource

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonDocumentSource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in CommonDocumentSource: required")
	}
	if _, ok := raw["loc"]; raw != nil && !ok {
		return fmt.Errorf("field loc in CommonDocumentSource: required")
	}
	if _, ok := raw["rep"]; raw != nil && !ok {
		return fmt.Errorf("field rep in CommonDocumentSource: required")
	}
	type Plain CommonDocumentSource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Loc) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "loc", 1)
	}
	if len(plain.Loc) > 8000 {
		return fmt.Errorf("field %s length: must be <= %d", "loc", 8000)
	}
	if len(plain.Rep) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "rep", 1)
	}
	if len(plain.Rep) > 200 {
		return fmt.Errorf("field %s length: must be <= %d", "rep", 200)
	}
	if plain.Ver != nil && len(*plain.Ver) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "ver", 1)
	}
	if plain.Ver != nil && len(*plain.Ver) > 200 {
		return fmt.Errorf("field %s length: must be <= %d", "ver", 200)
	}
	*j = CommonDocumentSource(plain)
	return nil
}

type Descriptor interface{}

// Unique identifier for the descriptor.
type DescriptorKey string

// A numeric value.
type DescriptorNumericValue float64

// A textual value, either an enumerated or free value.
type DescriptorTextValue string

type DescriptorValue interface{}

// Sources that contained the original definitions.  A tool collected those
// descriptions into this document.
type DocumentSources []SourceLocation

// A single ontological descriptor for a sourced object which only allows string
// values from a limited collection.
type EnumDescriptor struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// If true, the descriptor's value list may not contain multiple items with the
	// same value.
	Distinct bool `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// Allowed values for the descriptor.  While the allowed list of values has a
	// maximum, projects that require a larger number of values should instead
	// consider using a value pattern instead.
	Enum []string `json:"enum" yaml:"enum" mapstructure:"enum"`

	// Key corresponds to the JSON schema field "key".
	Key DescriptorKey `json:"key" yaml:"key" mapstructure:"key"`

	// Maximum number of values contained in a single descriptor.  If 'distinct' is
	// true, then this is the maximum number of distinct values.  Defaults to 1.
	MaximumCount int `json:"maximumCount,omitempty" yaml:"maximumCount,omitempty" mapstructure:"maximumCount,omitempty"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor defined by this definition.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnumDescriptor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["enum"]; raw != nil && !ok {
		return fmt.Errorf("field enum in EnumDescriptor: required")
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in EnumDescriptor: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in EnumDescriptor: required")
	}
	type Plain EnumDescriptor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["distinct"]; !ok || v == nil {
		plain.Distinct = false
	}
	if v, ok := raw["maximumCount"]; !ok || v == nil {
		plain.MaximumCount = 1.0
	}
	*j = EnumDescriptor(plain)
	return nil
}

// A single ontological descriptor for a sourced object.  Note that systems that
// record the values, it should trim surrounding whitespace, and condense internal
// whitespace to a single value (so 'A  B   C' becomes 'A B C').
type FreeDescriptor struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Determines whether the systems interpret values exactly as written, or if it
	// should ignore the case.  By default, all descriptors ignore value case.  Case
	// sensitivity should, where possible, ignore case for the complete UTF
	// characters.
	CaseSensitive bool `json:"caseSensitive,omitempty" yaml:"caseSensitive,omitempty" mapstructure:"caseSensitive,omitempty"`

	// A list of limitations for the allowed values for this descriptor.  If the list
	// contains multiple constraints, the descriptor value must apply to all of them.
	Constraints []ValueConstraint `json:"constraints,omitempty" yaml:"constraints,omitempty" mapstructure:"constraints,omitempty"`

	// If true, the descriptor's value list may not contain multiple items with the
	// same value.
	Distinct bool `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key DescriptorKey `json:"key" yaml:"key" mapstructure:"key"`

	// Maximum number of values contained in a single descriptor.  If 'distinct' is
	// true, then this is the maximum number of distinct values.  Default is '1'.
	MaximumCount int `json:"maximumCount,omitempty" yaml:"maximumCount,omitempty" mapstructure:"maximumCount,omitempty"`

	// Maximum number of characters of the free value.  In the case of UTF-8, each
	// diacritic mark counts as a character.
	MaximumLength int `json:"maximumLength,omitempty" yaml:"maximumLength,omitempty" mapstructure:"maximumLength,omitempty"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor defined by this definition.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FreeDescriptor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in FreeDescriptor: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in FreeDescriptor: required")
	}
	type Plain FreeDescriptor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["caseSensitive"]; !ok || v == nil {
		plain.CaseSensitive = false
	}
	if v, ok := raw["distinct"]; !ok || v == nil {
		plain.Distinct = false
	}
	if v, ok := raw["maximumCount"]; !ok || v == nil {
		plain.MaximumCount = 1.0
	}
	if v, ok := raw["maximumLength"]; !ok || v == nil {
		plain.MaximumLength = 1000.0
	}
	*j = FreeDescriptor(plain)
	return nil
}

// Unique identifying string for the item.  These should be ASCII alpha-numeric +
// simple separators.
type Id string

// A single ontological descriptor for a sourced object.  Note that systems that
// record the values, it should trim surrounding whitespace, and condense internal
// whitespace to a single value (so 'A  B   C' becomes 'A B C').  The 'minimum'
// must be less than or equal to the 'maximum' value.
type NumericDescriptor struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// If true, the descriptor's value list may not contain multiple items with the
	// same value.
	Distinct bool `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key DescriptorKey `json:"key" yaml:"key" mapstructure:"key"`

	// Maximum corresponds to the JSON schema field "maximum".
	Maximum DescriptorNumericValue `json:"maximum" yaml:"maximum" mapstructure:"maximum"`

	// Maximum number of values contained in a single descriptor.  If 'distinct' is
	// true, then this is the maximum number of distinct values.  The default is 1.
	// Minimum is 1, because it doesn't make sense to define a descriptor that does
	// not allow values - all objects contain at least zero values for all
	// descriptors.
	MaximumCount int `json:"maximumCount,omitempty" yaml:"maximumCount,omitempty" mapstructure:"maximumCount,omitempty"`

	// Minimum corresponds to the JSON schema field "minimum".
	Minimum DescriptorNumericValue `json:"minimum" yaml:"minimum" mapstructure:"minimum"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor defined by this definition.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NumericDescriptor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in NumericDescriptor: required")
	}
	if _, ok := raw["maximum"]; raw != nil && !ok {
		return fmt.Errorf("field maximum in NumericDescriptor: required")
	}
	if _, ok := raw["minimum"]; raw != nil && !ok {
		return fmt.Errorf("field minimum in NumericDescriptor: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NumericDescriptor: required")
	}
	type Plain NumericDescriptor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["distinct"]; !ok || v == nil {
		plain.Distinct = false
	}
	if v, ok := raw["maximumCount"]; !ok || v == nil {
		plain.MaximumCount = 1.0
	}
	*j = NumericDescriptor(plain)
	return nil
}

// Description of the descriptors used for a hierarchy of objects.  STATUS: ready
// for review
type OntologyV1SchemaJson struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Schema corresponds to the JSON schema field "$schema".
	Schema Schema `json:"$schema" yaml:"$schema" mapstructure:"$schema"`

	// CommonSourceRefs corresponds to the JSON schema field "commonSourceRefs".
	CommonSourceRefs CommonDocumentSourceList `json:"commonSourceRefs,omitempty" yaml:"commonSourceRefs,omitempty" mapstructure:"commonSourceRefs,omitempty"`

	// List of ontology descriptors supported.  If necessary, additional descriptors
	// may live in accompanying document files.
	Descriptors []OntologyV1SchemaJsonDescriptorsElem `json:"descriptors" yaml:"descriptors" mapstructure:"descriptors"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`
}

type OntologyV1SchemaJsonDescriptorsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OntologyV1SchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["$schema"]; raw != nil && !ok {
		return fmt.Errorf("field $schema in OntologyV1SchemaJson: required")
	}
	if _, ok := raw["descriptors"]; raw != nil && !ok {
		return fmt.Errorf("field descriptors in OntologyV1SchemaJson: required")
	}
	type Plain OntologyV1SchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OntologyV1SchemaJson(plain)
	return nil
}

// Data exchange schema format.
type Schema string

// Pointer to the location of the source.  Due to the prevalence of this object,
// property names use a truncated form to shrink file sizes.  The 'ref' points to a
// common document source identifier in the commonSourceRefs list.
type SourceLocation struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// A location within the source.  This depends upon the source type; it might be
	// an HTML anchor tag, or a paragraph title, or a function name, or a line number,
	// or an opcode index.
	A *string `json:"a,omitempty" yaml:"a,omitempty" mapstructure:"a,omitempty"`

	// Ref corresponds to the JSON schema field "ref".
	Ref Id `json:"ref" yaml:"ref" mapstructure:"ref"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceLocation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["ref"]; raw != nil && !ok {
		return fmt.Errorf("field ref in SourceLocation: required")
	}
	type Plain SourceLocation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.A != nil && len(*plain.A) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "a", 1)
	}
	if plain.A != nil && len(*plain.A) > 4000 {
		return fmt.Errorf("field %s length: must be <= %d", "a", 4000)
	}
	*j = SourceLocation(plain)
	return nil
}

// A single restriction on the allowed value text.
type ValueConstraint struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// A pre-defined value format.  While a few formats should exist built-in, no
	// explicit list exists at this time.
	Format *string `json:"format,omitempty" yaml:"format,omitempty" mapstructure:"format,omitempty"`

	// Maximum corresponds to the JSON schema field "maximum".
	Maximum *DescriptorNumericValue `json:"maximum,omitempty" yaml:"maximum,omitempty" mapstructure:"maximum,omitempty"`

	// Minimum corresponds to the JSON schema field "minimum".
	Minimum *DescriptorNumericValue `json:"minimum,omitempty" yaml:"minimum,omitempty" mapstructure:"minimum,omitempty"`

	// Regular expression (non-backtracking) pattern the descriptor's values must
	// match.
	Pattern *string `json:"pattern,omitempty" yaml:"pattern,omitempty" mapstructure:"pattern,omitempty"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The kind of constraint to apply.
	Type ValueConstraintType `json:"type" yaml:"type" mapstructure:"type"`
}

type ValueConstraintType string

const ValueConstraintTypeFormat ValueConstraintType = "format"
const ValueConstraintTypeLength ValueConstraintType = "length"
const ValueConstraintTypePattern ValueConstraintType = "pattern"
const ValueConstraintTypeValueRange ValueConstraintType = "value-range"

var enumValues_ValueConstraintType = []interface{}{
	"pattern",
	"format",
	"length",
	"value-range",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ValueConstraintType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ValueConstraintType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ValueConstraintType, v)
	}
	*j = ValueConstraintType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ValueConstraint) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ValueConstraint: required")
	}
	type Plain ValueConstraint
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Format != nil && len(*plain.Format) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "format", 1)
	}
	if plain.Format != nil && len(*plain.Format) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "format", 100)
	}
	if plain.Pattern != nil && len(*plain.Pattern) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "pattern", 1)
	}
	if plain.Pattern != nil && len(*plain.Pattern) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "pattern", 1000)
	}
	*j = ValueConstraint(plain)
	return nil
}
