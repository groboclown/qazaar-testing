// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package rules

import "encoding/json"
import "fmt"
import "reflect"

// Defines how a descriptor value should change.  The values must match the allowed
// descriptor values.
type Alteration struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// The action to the base descriptor value to perform.
	Action AlterationAction `json:"action" yaml:"action" mapstructure:"action"`

	// Key corresponds to the JSON schema field "key".
	Key DescriptorKey `json:"key" yaml:"key" mapstructure:"key"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Values to alter in the descriptor.  For 'add' operation, all the values are
	// added, even if they already exist.  For 'remove' operation, any matching value
	// is removed; but only once for each value in this list.  For 'addDistinct', then
	// the value is added only if it does not already exist.  For 'removeDistinct',
	// all values that match are removed, regardless of the number of them.  For
	// 'set', the values are replaced with the new values.
	Values []AlterationValuesElem `json:"values" yaml:"values" mapstructure:"values"`
}

type AlterationAction string

const AlterationActionAdd AlterationAction = "add"
const AlterationActionAddDistinct AlterationAction = "addDistinct"
const AlterationActionRemove AlterationAction = "remove"
const AlterationActionRemoveDistinct AlterationAction = "removeDistinct"
const AlterationActionSet AlterationAction = "set"

var enumValues_AlterationAction = []interface{}{
	"add",
	"addDistinct",
	"remove",
	"removeDistinct",
	"set",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AlterationAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AlterationAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AlterationAction, v)
	}
	*j = AlterationAction(v)
	return nil
}

type AlterationValuesElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Alteration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["action"]; raw != nil && !ok {
		return fmt.Errorf("field action in Alteration: required")
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in Alteration: required")
	}
	if _, ok := raw["values"]; raw != nil && !ok {
		return fmt.Errorf("field values in Alteration: required")
	}
	type Plain Alteration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Alteration(plain)
	return nil
}

// A check on a collection of value checks, all of which must pass.
type AndCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Collection corresponds to the JSON schema field "collection".
	Collection ValueCheckList `json:"collection" yaml:"collection" mapstructure:"collection"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Marks the check as for a specific type.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AndCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in AndCheck: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AndCheck: required")
	}
	type Plain AndCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AndCheck(plain)
	return nil
}

// A collection of sub-matchers, of which all must match.
type AndMatcher struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Collection corresponds to the JSON schema field "collection".
	Collection MatcherCollection `json:"collection" yaml:"collection" mapstructure:"collection"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor matcher defined by this definition.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AndMatcher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in AndMatcher: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AndMatcher: required")
	}
	type Plain AndMatcher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AndMatcher(plain)
	return nil
}

// Document author comment text.
type Comment string

// List of document author comments.
type CommentList []Comment

// A shared primary document reference.  Source locations can refer to this
// document through the identifier, but should also include an anchor.
type CommonDocumentSource struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id Id `json:"id" yaml:"id" mapstructure:"id"`

	// The resource identifier within the 'repo'.  Depending on the repo type, this
	// most likely has a required format for that repository.
	Loc string `json:"loc" yaml:"loc" mapstructure:"loc"`

	// General repository category containing the source.  This might be 'git' if
	// stored in a Git repository, or 'aws-s3', if stored in an Amazon S3 key store,
	// or 'intranet' if stored in an Intranet source.  The different programs may have
	// their own requirements for this value.  It does not define a location within
	// the repository, though.
	Rep string `json:"rep" yaml:"rep" mapstructure:"rep"`

	// An identifier to reference the unique version of the source, as dictated by the
	// repository type.  This might a commit id, or document revision, or a date-time
	// stamp.  The repository type may not have the ability to retrieve this version
	// (someone may have deleted it, or the repository does not support versioning).
	Ver *string `json:"ver,omitempty" yaml:"ver,omitempty" mapstructure:"ver,omitempty"`
}

// Pool of document source references, which may be referenced from the source
// locations.
type CommonDocumentSourceList []CommonDocumentSource

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonDocumentSource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in CommonDocumentSource: required")
	}
	if _, ok := raw["loc"]; raw != nil && !ok {
		return fmt.Errorf("field loc in CommonDocumentSource: required")
	}
	if _, ok := raw["rep"]; raw != nil && !ok {
		return fmt.Errorf("field rep in CommonDocumentSource: required")
	}
	type Plain CommonDocumentSource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Loc) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "loc", 1)
	}
	if len(plain.Loc) > 8000 {
		return fmt.Errorf("field %s length: must be <= %d", "loc", 8000)
	}
	if len(plain.Rep) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "rep", 1)
	}
	if len(plain.Rep) > 200 {
		return fmt.Errorf("field %s length: must be <= %d", "rep", 200)
	}
	if plain.Ver != nil && len(*plain.Ver) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "ver", 1)
	}
	if plain.Ver != nil && len(*plain.Ver) > 200 {
		return fmt.Errorf("field %s length: must be <= %d", "ver", 200)
	}
	*j = CommonDocumentSource(plain)
	return nil
}

// A descriptor requirement for the item matching a rule.
type ConformityImplication struct {
	// Level corresponds to the JSON schema field "level".
	Level ImplicationLevel `json:"level" yaml:"level" mapstructure:"level"`

	// Matcher corresponds to the JSON schema field "matcher".
	Matcher ConformityImplicationMatcher `json:"matcher" yaml:"matcher" mapstructure:"matcher"`
}

type ConformityImplicationMatcher interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConformityImplication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in ConformityImplication: required")
	}
	if _, ok := raw["matcher"]; raw != nil && !ok {
		return fmt.Errorf("field matcher in ConformityImplication: required")
	}
	type Plain ConformityImplication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConformityImplication(plain)
	return nil
}

// Inverts the matching result of a sub-matcher.
type ContainsAllMatcher struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Count corresponds to the JSON schema field "count".
	Count bool `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Distinct corresponds to the JSON schema field "distinct".
	Distinct bool `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *DescriptorKey `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Matcher corresponds to the JSON schema field "matcher".
	Matcher ContainsAllMatcherMatcher `json:"matcher" yaml:"matcher" mapstructure:"matcher"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor matcher defined by this definition.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type ContainsAllMatcherMatcher interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContainsAllMatcher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["matcher"]; raw != nil && !ok {
		return fmt.Errorf("field matcher in ContainsAllMatcher: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ContainsAllMatcher: required")
	}
	type Plain ContainsAllMatcher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		plain.Count = false
	}
	if v, ok := raw["distinct"]; !ok || v == nil {
		plain.Distinct = false
	}
	*j = ContainsAllMatcher(plain)
	return nil
}

// Inverts the matching result of a sub-matcher.
type ContainsOnlyMatcher struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Count corresponds to the JSON schema field "count".
	Count bool `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Distinct corresponds to the JSON schema field "distinct".
	Distinct bool `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *DescriptorKey `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Matcher corresponds to the JSON schema field "matcher".
	Matcher ContainsOnlyMatcherMatcher `json:"matcher" yaml:"matcher" mapstructure:"matcher"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor matcher defined by this definition.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type ContainsOnlyMatcherMatcher interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContainsOnlyMatcher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["matcher"]; raw != nil && !ok {
		return fmt.Errorf("field matcher in ContainsOnlyMatcher: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ContainsOnlyMatcher: required")
	}
	type Plain ContainsOnlyMatcher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		plain.Count = false
	}
	if v, ok := raw["distinct"]; !ok || v == nil {
		plain.Distinct = false
	}
	*j = ContainsOnlyMatcher(plain)
	return nil
}

// Inverts the matching result of a sub-matcher.
type ContainsSomeMatcher struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Count corresponds to the JSON schema field "count".
	Count bool `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Distinct corresponds to the JSON schema field "distinct".
	Distinct bool `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key DescriptorKey `json:"key" yaml:"key" mapstructure:"key"`

	// Matcher corresponds to the JSON schema field "matcher".
	Matcher ContainsSomeMatcherMatcher `json:"matcher,omitempty" yaml:"matcher,omitempty" mapstructure:"matcher,omitempty"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor matcher defined by this definition.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type ContainsSomeMatcherMatcher interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContainsSomeMatcher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in ContainsSomeMatcher: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ContainsSomeMatcher: required")
	}
	type Plain ContainsSomeMatcher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		plain.Count = false
	}
	if v, ok := raw["distinct"]; !ok || v == nil {
		plain.Distinct = false
	}
	*j = ContainsSomeMatcher(plain)
	return nil
}

// A descriptor requirement for all members of a Self-Organizing Group
type ConvergenceImplication struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// True means to examine the values within each member as distinct (they only
	// appear at most once).
	Distinct bool `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key DescriptorKey `json:"key" yaml:"key" mapstructure:"key"`

	// Level corresponds to the JSON schema field "level".
	Level ImplicationLevel `json:"level" yaml:"level" mapstructure:"level"`

	// How the descriptor's values must align between the SOG members. 'allMatch'
	// means that each member's values must all be identical.  'disjoint' means that
	// each value can exist in, at most, one member.
	Requires ConvergenceImplicationRequires `json:"requires" yaml:"requires" mapstructure:"requires"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`
}

type ConvergenceImplicationRequires string

const ConvergenceImplicationRequiresAllMatch ConvergenceImplicationRequires = "allMatch"
const ConvergenceImplicationRequiresDisjoint ConvergenceImplicationRequires = "disjoint"

var enumValues_ConvergenceImplicationRequires = []interface{}{
	"allMatch",
	"disjoint",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConvergenceImplicationRequires) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConvergenceImplicationRequires {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConvergenceImplicationRequires, v)
	}
	*j = ConvergenceImplicationRequires(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConvergenceImplication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in ConvergenceImplication: required")
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in ConvergenceImplication: required")
	}
	if _, ok := raw["requires"]; raw != nil && !ok {
		return fmt.Errorf("field requires in ConvergenceImplication: required")
	}
	type Plain ConvergenceImplication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["distinct"]; !ok || v == nil {
		plain.Distinct = false
	}
	*j = ConvergenceImplication(plain)
	return nil
}

// Unique identifier for the descriptor.
type DescriptorKey string

// A numeric value.
type DescriptorNumericValue float64

// A textual value, either an enumerated or free value.
type DescriptorTextValue string

type DescriptorValue interface{}

// Sources that contained the original definitions.  A tool collected those
// descriptions into this document.
type DocumentSources []SourceLocation

// A self-organizing group definition.
type Group struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// List of descriptor alterations to perform on the generated SOG.
	Alterations []Alteration `json:"alterations,omitempty" yaml:"alterations,omitempty" mapstructure:"alterations,omitempty"`

	// List of SOG convergence implications.
	Convergences []ConvergenceImplication `json:"convergences,omitempty" yaml:"convergences,omitempty" mapstructure:"convergences,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *Id `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// List of descriptor rules that, when all match, mark items for group creation.
	MatchingDescriptors []GroupMatchingDescriptorsElem `json:"matchingDescriptors,omitempty" yaml:"matchingDescriptors,omitempty" mapstructure:"matchingDescriptors,omitempty"`

	// List of descriptor keys whose matching values constructs a single SOG.
	SharedValues []DescriptorKey `json:"sharedValues" yaml:"sharedValues" mapstructure:"sharedValues"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// List of simple variables which an external system may define for replacement
	// within the values.
	Variables []Variable `json:"variables,omitempty" yaml:"variables,omitempty" mapstructure:"variables,omitempty"`
}

type GroupMatchingDescriptorsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Group) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["sharedValues"]; raw != nil && !ok {
		return fmt.Errorf("field sharedValues in Group: required")
	}
	type Plain Group
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Group(plain)
	return nil
}

// Unique identifying string for the item.  These should be ASCII alpha-numeric +
// simple separators.
type Id string

// Level of severity for the implication.  The executing system declares allowed
// values, and uses these to determine the enforcement requirements for the
// implication.
type ImplicationLevel string

// A collection of one or more sub-matchers.
type MatcherCollection []interface{}

type MatchingDescriptor interface{}

// Inverts the contained value check.
type NotCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Check corresponds to the JSON schema field "check".
	Check NotCheckCheck `json:"check" yaml:"check" mapstructure:"check"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Marks the check as for a specific type.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type NotCheckCheck interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["check"]; raw != nil && !ok {
		return fmt.Errorf("field check in NotCheck: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NotCheck: required")
	}
	type Plain NotCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NotCheck(plain)
	return nil
}

// Inverts the matching result of a sub-matcher.
type NotMatcher struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Matcher corresponds to the JSON schema field "matcher".
	Matcher NotMatcherMatcher `json:"matcher" yaml:"matcher" mapstructure:"matcher"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor matcher defined by this definition.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type NotMatcherMatcher interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotMatcher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["matcher"]; raw != nil && !ok {
		return fmt.Errorf("field matcher in NotMatcher: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NotMatcher: required")
	}
	type Plain NotMatcher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NotMatcher(plain)
	return nil
}

// A check for whether a numeric value obeys a boundary.  (Minimum and maximum
// allowed values come from the ontology)
type NumericWithinCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Maximum corresponds to the JSON schema field "maximum".
	Maximum DescriptorNumericValue `json:"maximum" yaml:"maximum" mapstructure:"maximum"`

	// Minimum corresponds to the JSON schema field "minimum".
	Minimum DescriptorNumericValue `json:"minimum" yaml:"minimum" mapstructure:"minimum"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Marks the check as for a specific type.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NumericWithinCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["maximum"]; raw != nil && !ok {
		return fmt.Errorf("field maximum in NumericWithinCheck: required")
	}
	if _, ok := raw["minimum"]; raw != nil && !ok {
		return fmt.Errorf("field minimum in NumericWithinCheck: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NumericWithinCheck: required")
	}
	type Plain NumericWithinCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NumericWithinCheck(plain)
	return nil
}

// A check on a collection of value checks, at least one of which must pass.
type OrCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Collection corresponds to the JSON schema field "collection".
	Collection ValueCheckList `json:"collection" yaml:"collection" mapstructure:"collection"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Marks the check as for a specific type.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in OrCheck: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in OrCheck: required")
	}
	type Plain OrCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OrCheck(plain)
	return nil
}

// A collection of sub-matchers, of which at least one must match.
type OrMatcher struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Collection corresponds to the JSON schema field "collection".
	Collection MatcherCollection `json:"collection" yaml:"collection" mapstructure:"collection"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor matcher defined by this definition.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrMatcher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in OrMatcher: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in OrMatcher: required")
	}
	type Plain OrMatcher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OrMatcher(plain)
	return nil
}

// A rule which includes matching descriptors and implications.
type Rule struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// List of conformity implications.
	Conformities []ConformityImplication `json:"conformities,omitempty" yaml:"conformities,omitempty" mapstructure:"conformities,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *Id `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// List of descriptor rules that, when all match, mark items as affected by the
	// rule.
	MatchingDescriptors []RuleMatchingDescriptorsElem `json:"matchingDescriptors" yaml:"matchingDescriptors" mapstructure:"matchingDescriptors"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// List of simple variables which an external system may define for replacement
	// within the values.
	Variables []Variable `json:"variables,omitempty" yaml:"variables,omitempty" mapstructure:"variables,omitempty"`
}

type RuleMatchingDescriptorsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Rule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["matchingDescriptors"]; raw != nil && !ok {
		return fmt.Errorf("field matchingDescriptors in Rule: required")
	}
	type Plain Rule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Rule(plain)
	return nil
}

// Constructed rules that define restrictions and enforcements for documents.
// STATUS: ready for review
type RulesV1SchemaJson struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Schema corresponds to the JSON schema field "$schema".
	Schema Schema `json:"$schema" yaml:"$schema" mapstructure:"$schema"`

	// CommonSourceRefs corresponds to the JSON schema field "commonSourceRefs".
	CommonSourceRefs CommonDocumentSourceList `json:"commonSourceRefs,omitempty" yaml:"commonSourceRefs,omitempty" mapstructure:"commonSourceRefs,omitempty"`

	// List of self-organizing group definitions.  If necessary, additional groups may
	// live in accompanying document files.
	Groups []Group `json:"groups,omitempty" yaml:"groups,omitempty" mapstructure:"groups,omitempty"`

	// List of rules.  If necessary, additional rules may live in accompanying
	// document files.
	Rules []Rule `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RulesV1SchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["$schema"]; raw != nil && !ok {
		return fmt.Errorf("field $schema in RulesV1SchemaJson: required")
	}
	type Plain RulesV1SchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RulesV1SchemaJson(plain)
	return nil
}

// Data exchange schema format.
type Schema string

// Pointer to the location of the source.  Due to the prevalence of this object,
// property names use a truncated form to shrink file sizes.  The 'ref' points to a
// common document source identifier in the commonSourceRefs list.
type SourceLocation struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// A location within the source.  This depends upon the source type; it might be
	// an HTML anchor tag, or a paragraph title, or a function name, or a line number,
	// or an opcode index.
	A *string `json:"a,omitempty" yaml:"a,omitempty" mapstructure:"a,omitempty"`

	// Ref corresponds to the JSON schema field "ref".
	Ref Id `json:"ref" yaml:"ref" mapstructure:"ref"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceLocation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["ref"]; raw != nil && !ok {
		return fmt.Errorf("field ref in SourceLocation: required")
	}
	type Plain SourceLocation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.A != nil && len(*plain.A) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "a", 1)
	}
	if plain.A != nil && len(*plain.A) > 4000 {
		return fmt.Errorf("field %s length: must be <= %d", "a", 4000)
	}
	*j = SourceLocation(plain)
	return nil
}

// An exact match for string values.  Equality checking follows the value's case
// sensitivity ontology setting.
type StringEqualCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Equals corresponds to the JSON schema field "equals".
	Equals DescriptorTextValue `json:"equals" yaml:"equals" mapstructure:"equals"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Marks the check as for a specific type.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StringEqualCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["equals"]; raw != nil && !ok {
		return fmt.Errorf("field equals in StringEqualCheck: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in StringEqualCheck: required")
	}
	type Plain StringEqualCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StringEqualCheck(plain)
	return nil
}

// A regular-expression pattern for string values.  Expression pattern checking
// follows the value's case sensitivity ontology setting.
type StringPatternCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Marks the check as for a specific type.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StringPatternCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in StringPatternCheck: required")
	}
	type Plain StringPatternCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StringPatternCheck(plain)
	return nil
}

type ValueCheck interface{}

// List of checks for a descriptor's value.  The descriptor value type must match
// the check value type.
type ValueCheckList []interface{}

// A simple key to replace its text within a rule or group definition.  The value
// must be considered a single 'token' (such as a descriptor key or value).  The
// replacement matches '${variable-name}'
type Variable struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Optional text describing the purpose of the variable.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Name of the variable, as replaced within the text.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Helper for tools to restrict the possible allowed values for the type.
	// Generally tool specific, but at a minimum must support 'text', 'number', and
	// 'integer'.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Variable) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Variable: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Variable: required")
	}
	type Plain Variable
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1000)
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Name) > 200 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 200)
	}
	if len(plain.Type) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "type", 1)
	}
	if len(plain.Type) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "type", 1000)
	}
	*j = Variable(plain)
	return nil
}
