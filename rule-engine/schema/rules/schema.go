// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package rules

import "encoding/json"
import "fmt"
import "reflect"

// Defines how a descriptor value should change.  The values must match the allowed
// descriptor values.
type Alteration struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// The action to the base descriptor value to perform.
	Action AlterationAction `json:"action" yaml:"action" mapstructure:"action"`

	// Key corresponds to the JSON schema field "key".
	Key DescriptorKey `json:"key" yaml:"key" mapstructure:"key"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Values to alter in the descriptor.  For 'add' operation, all the values are
	// added, even if they already exist.  For 'remove' operation, any matching value
	// is removed; but only once for each value in this list.  For 'addDistinct', then
	// the value is added only if it does not already exist.  For 'removeDistinct',
	// all values that match are removed, regardless of the number of them.  For
	// 'set', the values are replaced with the new values.
	Values []AlterationValuesElem `json:"values" yaml:"values" mapstructure:"values"`
}

type AlterationAction string

const AlterationActionAdd AlterationAction = "add"
const AlterationActionAddDistinct AlterationAction = "addDistinct"
const AlterationActionRemove AlterationAction = "remove"
const AlterationActionRemoveDistinct AlterationAction = "removeDistinct"
const AlterationActionSet AlterationAction = "set"

var enumValues_AlterationAction = []interface{}{
	"add",
	"addDistinct",
	"remove",
	"removeDistinct",
	"set",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AlterationAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AlterationAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AlterationAction, v)
	}
	*j = AlterationAction(v)
	return nil
}

type AlterationValuesElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Alteration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["action"]; raw != nil && !ok {
		return fmt.Errorf("field action in Alteration: required")
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in Alteration: required")
	}
	if _, ok := raw["values"]; raw != nil && !ok {
		return fmt.Errorf("field values in Alteration: required")
	}
	type Plain Alteration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Alteration(plain)
	return nil
}

// A check on a collection of value checks, or: at least one of which must pass;
// and: all of which must pass.
type CollectionCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Collection corresponds to the JSON schema field "collection".
	Collection ValueCheckList `json:"collection" yaml:"collection" mapstructure:"collection"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Marks the check as for a specific type.
	Type CollectionCheckType `json:"type" yaml:"type" mapstructure:"type"`
}

type CollectionCheckType string

const CollectionCheckTypeAnd CollectionCheckType = "and"
const CollectionCheckTypeOr CollectionCheckType = "or"

var enumValues_CollectionCheckType = []interface{}{
	"or",
	"and",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionCheckType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CollectionCheckType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CollectionCheckType, v)
	}
	*j = CollectionCheckType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in CollectionCheck: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CollectionCheck: required")
	}
	type Plain CollectionCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CollectionCheck(plain)
	return nil
}

// A collection of sub-matchers, or: of which at least one must match; and: all
// must match.
type CollectionMatcher struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Collection corresponds to the JSON schema field "collection".
	Collection MatcherCollection `json:"collection" yaml:"collection" mapstructure:"collection"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor matcher defined by this definition.
	Type CollectionMatcherType `json:"type" yaml:"type" mapstructure:"type"`
}

type CollectionMatcherType string

const CollectionMatcherTypeAnd CollectionMatcherType = "and"
const CollectionMatcherTypeOr CollectionMatcherType = "or"

var enumValues_CollectionMatcherType = []interface{}{
	"or",
	"and",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionMatcherType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CollectionMatcherType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CollectionMatcherType, v)
	}
	*j = CollectionMatcherType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionMatcher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in CollectionMatcher: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CollectionMatcher: required")
	}
	type Plain CollectionMatcher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CollectionMatcher(plain)
	return nil
}

// Document author comment text.
type Comment string

// List of document author comments.
type CommentList []Comment

// A shared primary document reference.  Source locations can refer to this
// document through the identifier, but should also include an anchor.
type CommonDocumentSource struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id Id `json:"id" yaml:"id" mapstructure:"id"`

	// The resource identifier within the 'repo'.  Depending on the repo type, this
	// most likely has a required format for that repository.
	Loc string `json:"loc" yaml:"loc" mapstructure:"loc"`

	// General repository category containing the source.  This might be 'git' if
	// stored in a Git repository, or 'aws-s3', if stored in an Amazon S3 key store,
	// or 'intranet' if stored in an Intranet source.  The different programs may have
	// their own requirements for this value.  It does not define a location within
	// the repository, though.
	Rep string `json:"rep" yaml:"rep" mapstructure:"rep"`

	// An identifier to reference the unique version of the source, as dictated by the
	// repository type.  This might a commit id, or document revision, or a date-time
	// stamp.  The repository type may not have the ability to retrieve this version
	// (someone may have deleted it, or the repository does not support versioning).
	Ver *string `json:"ver,omitempty" yaml:"ver,omitempty" mapstructure:"ver,omitempty"`
}

// Pool of document source references, which may be referenced from the source
// locations.
type CommonDocumentSourceList []CommonDocumentSource

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonDocumentSource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in CommonDocumentSource: required")
	}
	if _, ok := raw["loc"]; raw != nil && !ok {
		return fmt.Errorf("field loc in CommonDocumentSource: required")
	}
	if _, ok := raw["rep"]; raw != nil && !ok {
		return fmt.Errorf("field rep in CommonDocumentSource: required")
	}
	type Plain CommonDocumentSource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Loc) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "loc", 1)
	}
	if len(plain.Loc) > 8000 {
		return fmt.Errorf("field %s length: must be <= %d", "loc", 8000)
	}
	if len(plain.Rep) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "rep", 1)
	}
	if len(plain.Rep) > 200 {
		return fmt.Errorf("field %s length: must be <= %d", "rep", 200)
	}
	if plain.Ver != nil && len(*plain.Ver) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "ver", 1)
	}
	if plain.Ver != nil && len(*plain.Ver) > 200 {
		return fmt.Errorf("field %s length: must be <= %d", "ver", 200)
	}
	*j = CommonDocumentSource(plain)
	return nil
}

// A descriptor requirement for the item matching a rule.
type ConformityImplication struct {
	// Level corresponds to the JSON schema field "level".
	Level ImplicationLevel `json:"level" yaml:"level" mapstructure:"level"`

	// Matcher corresponds to the JSON schema field "matcher".
	Matcher ConformityImplicationMatcher `json:"matcher" yaml:"matcher" mapstructure:"matcher"`
}

type ConformityImplicationMatcher interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConformityImplication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in ConformityImplication: required")
	}
	if _, ok := raw["matcher"]; raw != nil && !ok {
		return fmt.Errorf("field matcher in ConformityImplication: required")
	}
	type Plain ConformityImplication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConformityImplication(plain)
	return nil
}

// containsSome: Ensures the descriptor's values contain at least one of the values
// in this matcher.  containsAll: Ensures the descriptor's values contain all of
// this matcher's values; could contain more.  containsExactly: Ensures the
// descriptor's values contain all of this matcher's values and no more.
// containsOnly: Ensures the descriptor's values are restricted to the matcher's
// values; cannot contain other values.
type ContainsMatcher struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Count corresponds to the JSON schema field "count".
	Count bool `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Distinct corresponds to the JSON schema field "distinct".
	Distinct bool `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key DescriptorKey `json:"key" yaml:"key" mapstructure:"key"`

	// Matcher corresponds to the JSON schema field "matcher".
	Matcher ValueCheckList `json:"matcher" yaml:"matcher" mapstructure:"matcher"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor matcher defined by this definition.
	Type ContainsMatcherType `json:"type" yaml:"type" mapstructure:"type"`
}

type ContainsMatcherType string

const ContainsMatcherTypeContainsAll ContainsMatcherType = "containsAll"
const ContainsMatcherTypeContainsExactly ContainsMatcherType = "containsExactly"
const ContainsMatcherTypeContainsOnly ContainsMatcherType = "containsOnly"
const ContainsMatcherTypeContainsSome ContainsMatcherType = "containsSome"

var enumValues_ContainsMatcherType = []interface{}{
	"containsSome",
	"containsAll",
	"containsExactly",
	"containsOnly",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContainsMatcherType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContainsMatcherType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContainsMatcherType, v)
	}
	*j = ContainsMatcherType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContainsMatcher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in ContainsMatcher: required")
	}
	if _, ok := raw["matcher"]; raw != nil && !ok {
		return fmt.Errorf("field matcher in ContainsMatcher: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ContainsMatcher: required")
	}
	type Plain ContainsMatcher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		plain.Count = false
	}
	if v, ok := raw["distinct"]; !ok || v == nil {
		plain.Distinct = false
	}
	*j = ContainsMatcher(plain)
	return nil
}

// A descriptor requirement for all members of a Self-Organizing Group
type ConvergenceImplication struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// True means to examine the values within each member as distinct (they only
	// appear at most once).
	Distinct bool `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key DescriptorKey `json:"key" yaml:"key" mapstructure:"key"`

	// Level corresponds to the JSON schema field "level".
	Level ImplicationLevel `json:"level" yaml:"level" mapstructure:"level"`

	// How the descriptor's values must align between the SOG members. 'allMatch'
	// means that each member's values must all be identical.  'disjoint' means that
	// each value can exist in, at most, one member.
	Requires ConvergenceImplicationRequires `json:"requires" yaml:"requires" mapstructure:"requires"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`
}

type ConvergenceImplicationRequires string

const ConvergenceImplicationRequiresAllMatch ConvergenceImplicationRequires = "allMatch"
const ConvergenceImplicationRequiresDisjoint ConvergenceImplicationRequires = "disjoint"

var enumValues_ConvergenceImplicationRequires = []interface{}{
	"allMatch",
	"disjoint",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConvergenceImplicationRequires) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConvergenceImplicationRequires {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConvergenceImplicationRequires, v)
	}
	*j = ConvergenceImplicationRequires(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConvergenceImplication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in ConvergenceImplication: required")
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in ConvergenceImplication: required")
	}
	if _, ok := raw["requires"]; raw != nil && !ok {
		return fmt.Errorf("field requires in ConvergenceImplication: required")
	}
	type Plain ConvergenceImplication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["distinct"]; !ok || v == nil {
		plain.Distinct = false
	}
	*j = ConvergenceImplication(plain)
	return nil
}

// Unique identifier for the descriptor.
type DescriptorKey string

// A numeric value.
type DescriptorNumericValue float64

// A textual value, either an enumerated or free value.
type DescriptorTextValue string

type DescriptorValue interface{}

// Sources that contained the original definitions.  A tool collected those
// descriptions into this document.
type DocumentSources []SourceLocation

// A self-organizing group definition.
type Group struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// List of descriptor alterations to perform on the generated SOG.
	Alterations []Alteration `json:"alterations,omitempty" yaml:"alterations,omitempty" mapstructure:"alterations,omitempty"`

	// List of SOG convergence implications.
	Convergences []ConvergenceImplication `json:"convergences,omitempty" yaml:"convergences,omitempty" mapstructure:"convergences,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id Id `json:"id" yaml:"id" mapstructure:"id"`

	// List of descriptor rules that, when all match, mark items for group creation.
	MatchingDescriptors []GroupMatchingDescriptorsElem `json:"matchingDescriptors,omitempty" yaml:"matchingDescriptors,omitempty" mapstructure:"matchingDescriptors,omitempty"`

	// List of descriptor keys whose matching values constructs a single SOG.
	SharedValues []DescriptorKey `json:"sharedValues" yaml:"sharedValues" mapstructure:"sharedValues"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// List of simple variables which an external system may define for replacement
	// within the values.
	Variables []Variable `json:"variables,omitempty" yaml:"variables,omitempty" mapstructure:"variables,omitempty"`
}

type GroupMatchingDescriptorsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Group) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Group: required")
	}
	if _, ok := raw["sharedValues"]; raw != nil && !ok {
		return fmt.Errorf("field sharedValues in Group: required")
	}
	type Plain Group
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Group(plain)
	return nil
}

// Unique identifying string for the item.  These should be ASCII alpha-numeric +
// simple separators.
type Id string

// Level of severity for the implication.  The executing system declares allowed
// values, and uses these to determine the enforcement requirements for the
// implication.
type ImplicationLevel string

// A collection of one or more sub-matchers.
type MatcherCollection []interface{}

type MatchingDescriptor interface{}

// Inverts the contained value check.
type NotCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Check corresponds to the JSON schema field "check".
	Check NotCheckCheck `json:"check" yaml:"check" mapstructure:"check"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Marks the check as for a specific type.
	Type NotCheckType `json:"type" yaml:"type" mapstructure:"type"`
}

type NotCheckCheck interface{}

type NotCheckType string

const NotCheckTypeNot NotCheckType = "not"

var enumValues_NotCheckType = []interface{}{
	"not",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotCheckType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NotCheckType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NotCheckType, v)
	}
	*j = NotCheckType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["check"]; raw != nil && !ok {
		return fmt.Errorf("field check in NotCheck: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NotCheck: required")
	}
	type Plain NotCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NotCheck(plain)
	return nil
}

// Inverts the matching result of a sub-matcher.
type NotMatcher struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Matcher corresponds to the JSON schema field "matcher".
	Matcher NotMatcherMatcher `json:"matcher" yaml:"matcher" mapstructure:"matcher"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// The type of descriptor matcher defined by this definition.
	Type NotMatcherType `json:"type" yaml:"type" mapstructure:"type"`
}

type NotMatcherMatcher interface{}

type NotMatcherType string

const NotMatcherTypeNot NotMatcherType = "not"

var enumValues_NotMatcherType = []interface{}{
	"not",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotMatcherType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NotMatcherType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NotMatcherType, v)
	}
	*j = NotMatcherType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotMatcher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["matcher"]; raw != nil && !ok {
		return fmt.Errorf("field matcher in NotMatcher: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NotMatcher: required")
	}
	type Plain NotMatcher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NotMatcher(plain)
	return nil
}

// A check for whether a numeric value obeys a boundary.  (Minimum and maximum
// allowed values come from the ontology)
type NumericBoundsCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Maximum corresponds to the JSON schema field "maximum".
	Maximum DescriptorNumericValue `json:"maximum" yaml:"maximum" mapstructure:"maximum"`

	// Minimum corresponds to the JSON schema field "minimum".
	Minimum DescriptorNumericValue `json:"minimum" yaml:"minimum" mapstructure:"minimum"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Marks the check as for a specific type.
	Type NumericBoundsCheckType `json:"type" yaml:"type" mapstructure:"type"`
}

type NumericBoundsCheckType string

const NumericBoundsCheckTypeWithin NumericBoundsCheckType = "within"

var enumValues_NumericBoundsCheckType = []interface{}{
	"within",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NumericBoundsCheckType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NumericBoundsCheckType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NumericBoundsCheckType, v)
	}
	*j = NumericBoundsCheckType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NumericBoundsCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["maximum"]; raw != nil && !ok {
		return fmt.Errorf("field maximum in NumericBoundsCheck: required")
	}
	if _, ok := raw["minimum"]; raw != nil && !ok {
		return fmt.Errorf("field minimum in NumericBoundsCheck: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NumericBoundsCheck: required")
	}
	type Plain NumericBoundsCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NumericBoundsCheck(plain)
	return nil
}

// A rule which includes matching descriptors and implications.
type Rule struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// List of conformity implications.
	Conformities []ConformityImplication `json:"conformities,omitempty" yaml:"conformities,omitempty" mapstructure:"conformities,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id Id `json:"id" yaml:"id" mapstructure:"id"`

	// List of descriptor rules that, when all match, mark items as affected by the
	// rule.
	MatchingDescriptors []RuleMatchingDescriptorsElem `json:"matchingDescriptors" yaml:"matchingDescriptors" mapstructure:"matchingDescriptors"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// List of simple variables which an external system may define for replacement
	// within the values.
	Variables []Variable `json:"variables,omitempty" yaml:"variables,omitempty" mapstructure:"variables,omitempty"`
}

type RuleMatchingDescriptorsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Rule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Rule: required")
	}
	if _, ok := raw["matchingDescriptors"]; raw != nil && !ok {
		return fmt.Errorf("field matchingDescriptors in Rule: required")
	}
	type Plain Rule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Rule(plain)
	return nil
}

// Constructed rules that define restrictions and enforcements for documents.
// STATUS: ready for review
type RulesV1SchemaJson struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Schema corresponds to the JSON schema field "$schema".
	Schema Schema `json:"$schema" yaml:"$schema" mapstructure:"$schema"`

	// CommonSourceRefs corresponds to the JSON schema field "commonSourceRefs".
	CommonSourceRefs CommonDocumentSourceList `json:"commonSourceRefs,omitempty" yaml:"commonSourceRefs,omitempty" mapstructure:"commonSourceRefs,omitempty"`

	// List of self-organizing group definitions.  If necessary, additional groups may
	// live in accompanying document files.
	Groups []Group `json:"groups,omitempty" yaml:"groups,omitempty" mapstructure:"groups,omitempty"`

	// List of rules.  If necessary, additional rules may live in accompanying
	// document files.
	Rules []Rule `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RulesV1SchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["$schema"]; raw != nil && !ok {
		return fmt.Errorf("field $schema in RulesV1SchemaJson: required")
	}
	type Plain RulesV1SchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RulesV1SchemaJson(plain)
	return nil
}

// Data exchange schema format.
type Schema string

// Pointer to the location of the source.  Due to the prevalence of this object,
// property names use a truncated form to shrink file sizes.  The 'ref' points to a
// common document source identifier in the commonSourceRefs list.
type SourceLocation struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// A location within the source.  This depends upon the source type; it might be
	// an HTML anchor tag, or a paragraph title, or a function name, or a line number,
	// or an opcode index.
	A *string `json:"a,omitempty" yaml:"a,omitempty" mapstructure:"a,omitempty"`

	// Ref corresponds to the JSON schema field "ref".
	Ref Id `json:"ref" yaml:"ref" mapstructure:"ref"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceLocation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["ref"]; raw != nil && !ok {
		return fmt.Errorf("field ref in SourceLocation: required")
	}
	type Plain SourceLocation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.A != nil && len(*plain.A) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "a", 1)
	}
	if plain.A != nil && len(*plain.A) > 4000 {
		return fmt.Errorf("field %s length: must be <= %d", "a", 4000)
	}
	*j = SourceLocation(plain)
	return nil
}

// A string equality or (non-lookahead) regular-expression pattern for string
// values.  Expression pattern checking follows the value's case sensitivity
// ontology setting.
type StringCheck struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Text corresponds to the JSON schema field "text".
	Text DescriptorTextValue `json:"text" yaml:"text" mapstructure:"text"`

	// Marks the check as for a specific type.
	Type StringCheckType `json:"type" yaml:"type" mapstructure:"type"`
}

type StringCheckType string

const StringCheckTypeEqual StringCheckType = "equal"
const StringCheckTypePattern StringCheckType = "pattern"

var enumValues_StringCheckType = []interface{}{
	"pattern",
	"equal",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StringCheckType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StringCheckType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StringCheckType, v)
	}
	*j = StringCheckType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StringCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in StringCheck: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in StringCheck: required")
	}
	type Plain StringCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StringCheck(plain)
	return nil
}

type ValueCheck interface{}

// List of checks for a descriptor's value.  The descriptor value type must match
// the check value type.
type ValueCheckList []interface{}

// A simple key to replace its text within a rule or group definition.  The value
// must be considered a single 'token' (such as a descriptor key or value).  The
// replacement matches '${variable-name}'
type Variable struct {
	// Comment corresponds to the JSON schema field "$comment".
	Comment *Comment `json:"$comment,omitempty" yaml:"$comment,omitempty" mapstructure:"$comment,omitempty"`

	// Comments corresponds to the JSON schema field "$comments".
	Comments CommentList `json:"$comments,omitempty" yaml:"$comments,omitempty" mapstructure:"$comments,omitempty"`

	// Optional text describing the purpose of the variable.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Name of the variable, as replaced within the text.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Sources corresponds to the JSON schema field "sources".
	Sources DocumentSources `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Helper for tools to restrict the possible allowed values for the type.
	// Generally tool specific, but at a minimum must support 'text', 'number', and
	// 'integer'.
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Variable) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Variable: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Variable: required")
	}
	type Plain Variable
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1000)
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Name) > 200 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 200)
	}
	if len(plain.Type) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "type", 1)
	}
	if len(plain.Type) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "type", 1000)
	}
	*j = Variable(plain)
	return nil
}
